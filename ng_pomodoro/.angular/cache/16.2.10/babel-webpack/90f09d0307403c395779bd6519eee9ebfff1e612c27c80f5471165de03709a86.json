{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component, Input } from '@angular/core';\nexport let TextComponent = class TextComponent {\n  constructor(sans) {\n    this.sans = sans;\n    this.text = \"\";\n    this.isTitle = false;\n    this.isSubtitle = false;\n    this.isText = false;\n    this.dir = 'left';\n    this.isEffect = false;\n    this.font = \"\";\n    this.titleSize = 2;\n    this.subtitleSize = 1.17;\n    this.textSize = 1;\n    this.titleFont = 'Bebas Neue';\n    this.subtitleFont = 'Bebas Neue';\n    this.textFont = 'IBM Plex Serif';\n    this.letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    this.lines = [];\n  }\n  ngOnInit() {\n    // this.isEffect = true;\n    this.splitLines();\n    /*\n    if(this.isEffect)\n    {\n         for(let i = 0; i < this.lines.length; i++)\n        {\n            this.lines[i] = this.lines[i].toUpperCase();\n            this.textEffect(-1, 1, i);\n        }\n    }\n    console.log(this.text);\n    this.lines = backup;\n    */\n    if (this.font !== \"\") {\n      if (this.isTitle) {\n        this.titleFont = this.font;\n      }\n      if (this.isSubtitle) {\n        this.subtitleFont = this.font;\n      }\n      if (this.isText) {\n        this.textFont = this.font;\n      }\n    }\n  }\n  splitLines() {\n    this.lines = this.text.split('\\n');\n    return this.lines;\n  }\n};\n__decorate([Input()], TextComponent.prototype, \"text\", void 0);\n__decorate([Input()], TextComponent.prototype, \"isTitle\", void 0);\n__decorate([Input()], TextComponent.prototype, \"isSubtitle\", void 0);\n__decorate([Input()], TextComponent.prototype, \"isText\", void 0);\n__decorate([Input()], TextComponent.prototype, \"dir\", void 0);\n__decorate([Input()], TextComponent.prototype, \"isEffect\", void 0);\n__decorate([Input()], TextComponent.prototype, \"font\", void 0);\n__decorate([Input()], TextComponent.prototype, \"titleSize\", void 0);\n__decorate([Input()], TextComponent.prototype, \"subtitleSize\", void 0);\n__decorate([Input()], TextComponent.prototype, \"textSize\", void 0);\nTextComponent = __decorate([Component({\n  selector: 'app-text',\n  templateUrl: './text.component.html',\n  styleUrls: ['./text.component.scss']\n})], TextComponent);","map":{"version":3,"names":["Component","Input","TextComponent","constructor","sans","text","isTitle","isSubtitle","isText","dir","isEffect","font","titleSize","subtitleSize","textSize","titleFont","subtitleFont","textFont","letters","lines","ngOnInit","splitLines","split","__decorate","selector","templateUrl","styleUrls"],"sources":["/mnt/d/programming/github/choisauce/ng_pomodoro/src/app/components/core/text/text.component.ts"],"sourcesContent":["import { Component, Input, Output } from '@angular/core';\nimport { SansService } from '../../../services/sans.service'\n\n@Component({\n  selector: 'app-text',\n  templateUrl: './text.component.html',\n  styleUrls: ['./text.component.scss']\n})\nexport class TextComponent {\n    @Input() text: string = \"\";\n    @Input() isTitle: boolean = false;\n    @Input() isSubtitle: boolean = false;\n    @Input() isText: boolean = false;\n    @Input() dir: string = 'left';\n    @Input() isEffect: boolean = false;\n    @Input() font: string = \"\";\n    @Input() titleSize: number = 2;\n    @Input() subtitleSize: number = 1.17;\n    @Input() textSize: number = 1;\n\n    titleFont: string = 'Bebas Neue'\n    subtitleFont: string = 'Bebas Neue'\n    textFont: string = 'IBM Plex Serif'\n\n    letters: string = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    lines: string[] = [];\n\n    constructor(public sans: SansService) {}\n\n    ngOnInit()\n    {\n        // this.isEffect = true;\n        this.splitLines()\n        /*\n        if(this.isEffect)\n        {\n\n            for(let i = 0; i < this.lines.length; i++)\n            {\n                this.lines[i] = this.lines[i].toUpperCase();\n                this.textEffect(-1, 1, i);\n            }\n        }\n        console.log(this.text);\n        this.lines = backup;\n        */\n\n       if(this.font !== \"\")\n       {\n           if(this.isTitle)\n           {\n               this.titleFont = this.font;\n           }\n           if(this.isSubtitle)\n           {\n               this.subtitleFont = this.font;\n           }\n           if(this.isText)\n           {\n               this.textFont = this.font;\n           }\n       }\n    }\n    \n\n    private splitLines()\n    {\n        this.lines = this.text.split('\\n');\n        return this.lines\n    }\n\n    /*\n    textEffect(iterations: number, increment: number, index: number)\n    {\n        const dirty: string = this.lines[index];\n        const toClean: boolean = this.cleanText(this.lines[index], index);\n        const initText : string = this.lines[index];\n\n        const interval = setInterval(() =>\n        {\n            this.lines[index]= this.lines[index].split(\"\")\n            .map((letter, index) => \n            {\n                if(letter === \" \")\n                {\n                    return \" \";\n                }\n                if(index < iterations)\n                {\n                    return initText[index];\n                }\n                return this.letters[Math.floor(Math.random() * 26)]\n            })\n            .join(\"\");\n            if(iterations >= initText.length)\n            {\n                clearInterval(interval);\n            }\n            iterations += 1 / increment;\n        }, .1)\n        let ret: any =  { bool: toClean, str: dirty};\n        return ret;\n    }\n\n    cleanText(text: string, index: number)\n    {\n        let val: string[] = text.split('<');\n        if(val.length === 1)\n        {\n            return false;\n        }\n        for(let i = 1; i < val.length; i++)\n        {\n            for(let j = 0; j < val[i].length; j++)\n            {\n                if(val[i][j] === '>')\n                {\n                    val[i] = val[i].substring(++j, val[i].length);\n                    break;\n                }\n            }\n        }\n        this.lines[index] = val.join('');\n        console.log(this.lines[index]);\n        return true;\n    }\n    */\n}\n"],"mappings":";AAAA,SAASA,SAAS,EAAEC,KAAK,QAAgB,eAAe;AAQjD,WAAMC,aAAa,GAAnB,MAAMA,aAAa;EAmBtBC,YAAmBC,IAAiB;IAAjB,KAAAA,IAAI,GAAJA,IAAI;IAlBd,KAAAC,IAAI,GAAW,EAAE;IACjB,KAAAC,OAAO,GAAY,KAAK;IACxB,KAAAC,UAAU,GAAY,KAAK;IAC3B,KAAAC,MAAM,GAAY,KAAK;IACvB,KAAAC,GAAG,GAAW,MAAM;IACpB,KAAAC,QAAQ,GAAY,KAAK;IACzB,KAAAC,IAAI,GAAW,EAAE;IACjB,KAAAC,SAAS,GAAW,CAAC;IACrB,KAAAC,YAAY,GAAW,IAAI;IAC3B,KAAAC,QAAQ,GAAW,CAAC;IAE7B,KAAAC,SAAS,GAAW,YAAY;IAChC,KAAAC,YAAY,GAAW,YAAY;IACnC,KAAAC,QAAQ,GAAW,gBAAgB;IAEnC,KAAAC,OAAO,GAAW,4BAA4B;IAC9C,KAAAC,KAAK,GAAa,EAAE;EAEmB;EAEvCC,QAAQA,CAAA;IAEJ;IACA,IAAI,CAACC,UAAU,EAAE;IACjB;;;;;;;;;;;;IAcD,IAAG,IAAI,CAACV,IAAI,KAAK,EAAE,EACnB;MACI,IAAG,IAAI,CAACL,OAAO,EACf;QACI,IAAI,CAACS,SAAS,GAAG,IAAI,CAACJ,IAAI;;MAE9B,IAAG,IAAI,CAACJ,UAAU,EAClB;QACI,IAAI,CAACS,YAAY,GAAG,IAAI,CAACL,IAAI;;MAEjC,IAAG,IAAI,CAACH,MAAM,EACd;QACI,IAAI,CAACS,QAAQ,GAAG,IAAI,CAACN,IAAI;;;EAGpC;EAGQU,UAAUA,CAAA;IAEd,IAAI,CAACF,KAAK,GAAG,IAAI,CAACd,IAAI,CAACiB,KAAK,CAAC,IAAI,CAAC;IAClC,OAAO,IAAI,CAACH,KAAK;EACrB;CA0DH;AAtHYI,UAAA,EAARtB,KAAK,EAAE,C,0CAAmB;AAClBsB,UAAA,EAARtB,KAAK,EAAE,C,6CAA0B;AACzBsB,UAAA,EAARtB,KAAK,EAAE,C,gDAA6B;AAC5BsB,UAAA,EAARtB,KAAK,EAAE,C,4CAAyB;AACxBsB,UAAA,EAARtB,KAAK,EAAE,C,yCAAsB;AACrBsB,UAAA,EAARtB,KAAK,EAAE,C,8CAA2B;AAC1BsB,UAAA,EAARtB,KAAK,EAAE,C,0CAAmB;AAClBsB,UAAA,EAARtB,KAAK,EAAE,C,+CAAuB;AACtBsB,UAAA,EAARtB,KAAK,EAAE,C,kDAA6B;AAC5BsB,UAAA,EAARtB,KAAK,EAAE,C,8CAAsB;AAVrBC,aAAa,GAAAqB,UAAA,EALzBvB,SAAS,CAAC;EACTwB,QAAQ,EAAE,UAAU;EACpBC,WAAW,EAAE,uBAAuB;EACpCC,SAAS,EAAE,CAAC,uBAAuB;CACpC,CAAC,C,EACWxB,aAAa,CAuHzB"},"metadata":{},"sourceType":"module","externalDependencies":[]}